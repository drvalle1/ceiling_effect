sample.t=function(z,y){
cond1=(y==0)
cond2=(y==1)
cond3=(y==2)
t1=runif(1, max(z[cond1], min(z[cond2])))
t2=runif(1, max(z[cond2], min(z[cond3])))
c(t1, t2)
}
ngibbs=1000
#N = length(dat$con)
b1 = 0
z = dat$y
t1 = 0.5
t2 = 1.5
results = matrix(NA, ngibbs, 3)
for(i in 1:ngibbs){
b1 = sample.b1(x=dat$con,z)
z=sample.z(b1,x=dat$con,y,t1,t2)
vec=sample.t(z,y)
t1=vec[1]
t2=vec[2]
results[i,] = c(b1,t1,t2)
}
traceback()
y
z = y
x=dat$con
tnorm(n=sum(y==0), lo=-Inf, hi=t1, mu=b1*x[y==0], sig=1)
tnorm(n=sum(y==1), lo=t1, hi=t2, mu=b1*x[y==1], sig=1)
t1
t2
#simulated data
set.seed(1)
n.con = 100
con = rep(c(0,62.5,125,250,500), each=n.con)
b1 = -0.02
z = rnorm(length(con), mean=b1*con, sd=1)
plot(con,z)
t1=-4.5#quantile(z,1/3)
t2=-1.5#quantile(z,2/3)
y = rep(NA, length(con))
y[z<t1]=0
y[z>t1&z<t2]=1
y[z>t2]=2
dat=data.frame(y=y,con=con)
#FCD for beta1
sample.b1 = function(x,z)
{sigma2 = (sum(x^2) + 1/10)^(-1)
b1 = rnorm(1,sigma2*sum(x*z),sd=sqrt(sigma2))
b1
}
#generates truncated normal variates based on cumulative normal distribution
tnorm <- function(n,lo,hi,mu,sig){
q1 <- pnorm(lo,mu,sig) #cumulative distribution
q2 <- pnorm(hi,mu,sig) #cumulative distribution
z <- runif(n,q1,q2)
z <- qnorm(z,mu,sig)
z[z == -Inf]  <- lo[z == -Inf]
z[z == Inf]   <- hi[z == Inf]
z
}
#FCD for zs
sample.z = function(b1, x, y, t1, t2){
z = y
z[y==0] = tnorm(n=sum(y==0), lo=-Inf, hi=t1, mu=b1*x[y==0], sig=1)
z[y==1] = tnorm(n=sum(y==1), lo=t1, hi=t2, mu=b1*x[y==1], sig=1)
z[y==2] = tnorm(n=sum(y==2), lo=t2, hi=Inf, mu=b1*x[y==2], sig=1)
z
}
#FCD for t1 and t2
sample.t=function(z,y){
cond1=(y==0)
cond2=(y==1)
cond3=(y==2)
t1=runif(1, max(z[cond1]), min(z[cond2]))
t2=runif(1, max(z[cond2]), min(z[cond3]))
c(t1, t2)
}
#Gibbs sampler
#Initial values
ngibbs=1000
#N = length(dat$con)
b1 = 0
z = dat$y
t1 = 0.5
t2 = 1.5
results = matrix(NA, ngibbs, 3)
for(i in 1:ngibbs){
b1 = sample.b1(x=dat$con,z)
z=sample.z(b1,x=dat$con,y,t1,t2)
vec=sample.t(z,y)
t1=vec[1]
t2=vec[2]
results[i,] = c(b1,t1,t2)
}
head(results)
plot(results[,1],type='l')
#simulated data
set.seed(1)
n.con = 100
con = rep(c(0,62.5,125,250,500), each=n.con)
b1 = -0.02
z = rnorm(length(con), mean=b1*con, sd=1)
plot(con,z)
t1=-4.5#quantile(z,1/3)
t2=-1.5#quantile(z,2/3)
y = rep(NA, length(con))
y[z<t1]=0
y[z>t1&z<t2]=1
y[z>t2]=2
dat=data.frame(y=y,con=con)
#FCD for beta1
sample.b1 = function(x,z)
{sigma2 = (sum(x^2) + 1/10)^(-1)
b1 = rnorm(1,sigma2*sum(x*z),sd=sqrt(sigma2))
b1
}
#generates truncated normal variates based on cumulative normal distribution
tnorm <- function(n,lo,hi,mu,sig){
q1 <- pnorm(lo,mu,sig) #cumulative distribution
q2 <- pnorm(hi,mu,sig) #cumulative distribution
z <- runif(n,q1,q2)
z <- qnorm(z,mu,sig)
z[z == -Inf]  <- lo[z == -Inf]
z[z == Inf]   <- hi[z == Inf]
z
}
#FCD for zs
sample.z = function(b1, x, y, t1, t2){
z = y
z[y==0] = tnorm(n=sum(y==0), lo=-Inf, hi=t1, mu=b1*x[y==0], sig=1)
z[y==1] = tnorm(n=sum(y==1), lo=t1, hi=t2, mu=b1*x[y==1], sig=1)
z[y==2] = tnorm(n=sum(y==2), lo=t2, hi=Inf, mu=b1*x[y==2], sig=1)
z
}
#FCD for t1 and t2
sample.t=function(z,y){
cond1=(y==0)
cond2=(y==1)
cond3=(y==2)
t1=runif(1, max(z[cond1]), min(z[cond2]))
t2=runif(1, max(z[cond2]), min(z[cond3]))
c(t1, t2)
}
#Gibbs sampler
#Initial values
ngibbs=10000
#N = length(dat$con)
b1 = 0
z = dat$y
t1 = 0.5
t2 = 1.5
results = matrix(NA, ngibbs, 3)
for(i in 1:ngibbs){
b1 = sample.b1(x=dat$con,z)
z=sample.z(b1,x=dat$con,y,t1,t2)
vec=sample.t(z,y)
t1=vec[1]
t2=vec[2]
results[i,] = c(b1,t1,t2)
}
plot(results[,1],type='l')
plot(results[,2],type='l')
plot(results[,3],type='l')
tuesday='bayes6560'
vec=c('socialscienceblade','baysocc','popeco',
'6560project','bayestrials')
sample(vec,size=length(vec))
rm(list=ls())
set.seed(111)
rm(list=ls())
set.seed(111)
b0=0
b1=0.1
x=seq(from=-5,to=5,length.out=100)
mu=exp(b0+b1*x)
n=0.5
p=n/(mu+n)
denom=1-(p^n)
ey=mu/denom
plot(x,ey)
plot(x,ey,ylim=range(c(ey,mu)))
points(x,mu,col='red')
0.1^0.1
range(denom)
range(1/denom)
hist(ey/mu)
rm(list=ls())
set.seed(111)
b0=0
b1=0.1
x=seq(from=-5,to=5,length.out=100)
mu=exp(b0+b1*x)
n=0.5
p=n/(mu+n)
denom=1-(p^n)
range(1/denom)
ey=mu/denom
plot(x,ey,ylim=range(c(ey,mu)))
points(x,mu,col='red')
rm(list=ls())
set.seed(111)
b0=0
b1=1
x=seq(from=-5,to=5,length.out=100)
mu=exp(b0+b1*x)
n=0.5
p=n/(mu+n)
denom=1-(p^n)
range(1/denom)
ey=mu/denom
plot(x,ey,ylim=range(c(ey,mu)))
points(x,mu,col='red')
rm(list=ls())
set.seed(111)
b0=2
b1=-0.1
x=seq(from=-5,to=5,length.out=100)
mu=exp(b0+b1*x)
n=0.5
p=n/(mu+n)
denom=1-(p^n)
range(1/denom)
ey=mu/denom
plot(x,ey,ylim=range(c(ey,mu)))
points(x,mu,col='red')
0.0001^0.1
?image_convert
rm(list=ls())
set.seed(1)
nobs=100
ceil1=7
floor1=1
mu=3
tau2=1
#generate pre-scores
pr=rnorm(nobs,mean=mu,sd=sqrt(tau2))
cond=pr>ceil1; sum(cond); pr[cond]=ceil1
cond=pr<floor1; sum(cond); pr[cond]=floor1
rm(list=ls())
set.seed(1)
nobs=100
ceil1=7
floor1=1
mu=3
tau2=1.5
#generate pre-scores
pr=rnorm(nobs,mean=mu,sd=sqrt(tau2))
cond=pr>ceil1;  sum(cond); pr[cond]=ceil1
cond=pr<floor1; sum(cond); pr[cond]=floor1
rm(list=ls())
set.seed(1)
nobs=100
ceil1=7
floor1=1
mu=3
tau2=2
#generate pre-scores
pr=rnorm(nobs,mean=mu,sd=sqrt(tau2))
cond=pr>ceil1;  sum(cond); pr[cond]=ceil1
cond=pr<floor1; sum(cond); pr[cond]=floor1
rm(list=ls())
set.seed(1)
nobs=100
ceil1=7
floor1=1
mu=5
tau2=2
#generate pre-scores
pr=rnorm(nobs,mean=mu,sd=sqrt(tau2))
cond=pr>ceil1;  sum(cond); pr[cond]=ceil1
cond=pr<floor1; sum(cond); pr[cond]=floor1
uniq=matrix(c(0,0,1,0,0,1),3,2,byrow=T)
uniq
rm(list=ls())
set.seed(1)
nobs=100
ceil1=7
floor1=1
mu=5
tau2=2
sig2=0.2
#generate pre-scores
pr=pr.true=rnorm(nobs,mean=mu,sd=sqrt(tau2))
cond=pr>ceil1;  sum(cond); pr[cond]=ceil1
cond=pr<floor1; sum(cond); pr[cond]=floor1
#generate xmat
uniq=matrix(c(0,0,1,0,0,1),3,2,byrow=T)
ind=sample(1:nrow(uniq),size=nobs,replace=T)
xmat=cbind(1,uniq[ind,])
colnames(xmat)=c('interc','trat1','trat2')
#generate xmat associated with pr
xmat.pr=cbind(pr,pr*xmat[,'trat1'],pr*xmat[,'trat2'])
xmat.pr.true=cbind(pr.true,pr.true*xmat[,'trat1'],pr.true*xmat[,'trat2'])
colnames(xmat.pr)=colnames(xmat.pr.true)=c('pr','pr_trat1','pr_trat2')
#parameters
betas=sample(c(-1,0,1),size=ncol(xmat),replace=T)
gammas=sample(c(-1,0,1),size=ncol(xmat.pr),replace=T)
rm(list=ls())
set.seed(1)
nobs=100
ceil1=7
floor1=1
mu=5
tau2=2
sig2=0.2
#generate pre-scores
pr=pr.true=rnorm(nobs,mean=mu,sd=sqrt(tau2))
cond=pr>ceil1;  sum(cond); pr[cond]=ceil1
cond=pr<floor1; sum(cond); pr[cond]=floor1
#generate xmat
uniq=matrix(c(0,0,1,0,0,1),3,2,byrow=T)
ind=sample(1:nrow(uniq),size=nobs,replace=T)
xmat=cbind(1,uniq[ind,])
colnames(xmat)=c('interc','trat1','trat2')
#generate xmat associated with pr
xmat.pr=cbind(pr,pr*xmat[,'trat1'],pr*xmat[,'trat2'])
xmat.pr.true=cbind(pr.true,pr.true*xmat[,'trat1'],pr.true*xmat[,'trat2'])
colnames(xmat.pr)=colnames(xmat.pr.true)=c('pr','pr_trat1','pr_trat2')
#parameters
betas=sample(c(-1,0,1),size=ncol(xmat),replace=T)
gammas=sample(c(-1,0,1),size=ncol(xmat.pr),replace=T)
media=xmat.pr%*%betas+xmat.pr.true%*%gammas
po=po.true=rnorm(nobs,mean=media,sd=sqrt(sig2))
cond=po>ceil1;  sum(cond); po[cond]=ceil1
cond=po<floor1; sum(cond); po[cond]=floor1
betas
gammas
rm(list=ls())
set.seed(1)
nobs=100
ceil1=7
floor1=1
mu=5
tau2=2
sig2=0.2
#generate pre-scores
pr=pr.true=rnorm(nobs,mean=mu,sd=sqrt(tau2))
cond=pr>ceil1;  sum(cond); pr[cond]=ceil1
cond=pr<floor1; sum(cond); pr[cond]=floor1
#generate xmat
uniq=matrix(c(0,0,1,0,0,1),3,2,byrow=T)
ind=sample(1:nrow(uniq),size=nobs,replace=T)
xmat=cbind(1,uniq[ind,])
colnames(xmat)=c('interc','trat1','trat2')
#generate xmat associated with pr
xmat.pr=cbind(pr,pr*xmat[,'trat1'],pr*xmat[,'trat2'])
xmat.pr.true=cbind(pr.true,pr.true*xmat[,'trat1'],pr.true*xmat[,'trat2'])
colnames(xmat.pr)=colnames(xmat.pr.true)=c('pr','pr_trat1','pr_trat2')
#parameters
betas=sample(c(-0.1,0,0.1),size=ncol(xmat),replace=T)
gammas=sample(c(-0.1,0,0.1),size=ncol(xmat.pr),replace=T)
#generate data
media=xmat.pr%*%betas+xmat.pr.true%*%gammas
po=po.true=rnorm(nobs,mean=media,sd=sqrt(sig2))
cond=po>ceil1;  sum(cond); po[cond]=ceil1
cond=po<floor1; sum(cond); po[cond]=floor1
rm(list=ls())
set.seed(1)
nobs=100
ceil1=7
floor1=1
mu=5
tau2=2
sig2=0.2
#generate pre-scores
pr=pr.true=rnorm(nobs,mean=mu,sd=sqrt(tau2))
cond=pr>ceil1;  sum(cond); pr[cond]=ceil1
cond=pr<floor1; sum(cond); pr[cond]=floor1
#generate xmat
uniq=matrix(c(0,0,1,0,0,1),3,2,byrow=T)
ind=sample(1:nrow(uniq),size=nobs,replace=T)
xmat=cbind(1,uniq[ind,])
colnames(xmat)=c('interc','trat1','trat2')
#generate xmat associated with pr
xmat.pr=cbind(pr,pr*xmat[,'trat1'],pr*xmat[,'trat2'])
xmat.pr.true=cbind(pr.true,pr.true*xmat[,'trat1'],pr.true*xmat[,'trat2'])
colnames(xmat.pr)=colnames(xmat.pr.true)=c('pr','pr_trat1','pr_trat2')
#parameters
betas=c(0,-0.1,0)
gammas=c(1,0,0.1)
#generate data
media=xmat.pr%*%betas+xmat.pr.true%*%gammas
po=po.true=rnorm(nobs,mean=media,sd=sqrt(sig2))
cond=po>ceil1;  sum(cond); po[cond]=ceil1
cond=po<floor1; sum(cond); po[cond]=floor1
fim=data.frame(po=po,pr=pr,xmat[,-1])
head(fim)
fim=data.frame(po=po,pr=pr,xmat[,-1])
plot(fim$pr,fim$po)
uniq
cores=rep('black',nrow(fim))
cond=fim$trat1==1; cores[cond]='red'
cond=fim$trat2==1; cores[cond]='blue'
plot(fim$pr,fim$po,col=cores)
cores=rep('black',nrow(fim))
cond=fim$trat1==1; cores[cond]='red'
cond=fim$trat2==1; cores[cond]='blue'
rango=c(floor1,ceil1)
plot(fim$pr,fim$po,col=cores,xlim=rango,ylim=rango)
lines(rango,rango,col='grey',lwd=2)
setwd('U:\\GIT_models\\ceiling_effect')
write.csv(fim,'fake data.csv',row.names=F)
rm(list=ls())
set.seed(1)
#get data
setwd('U:\\GIT_models\\ceiling_effect')
dat=read.csv('fake data.csv',as.is=T)
head(dat)
rm(list=ls())
set.seed(1)
#get data
setwd('U:\\GIT_models\\ceiling_effect')
source('gibbs_ceiling_functions.R')
dat=read.csv('fake data.csv',as.is=T)
xmat=cbind(1,dat[,c('trat1','trat2')])
colnames(xmat)[1]='interc'
#basic settings
ceil1=7
floor1=1
nobs=nrow(dat)
#initial values
betas=gammas=rep(0,ncol(xmat))
betas[1]=mean(dat$po)
sig2=var(dat$po)
mu=mean(dat$pr)
tau2=var(dat$pr)
pr.estim=dat$pr
po.estim=dat$po
#priors
invT=diag(1/10,ncol(xmat)*2)
a.prec=b.prec=0.1
#gibbs stuff
ngibbs=10000
store.betas=matrix(NA,ngibbs,length(betas))
store.gammas=matrix(NA,ngibbs,length(gammas))
store.others=matrix(NA,ngibbs,3)
betas.gammas=sample.betas.gammas(xmat=xmat,pr.estim=pr.estim,sig2=sig2,
po.estim=po.estim,invT=invT)
betas.gammas=sample.betas.gammas(xmat=xmat,pr.estim=pr.estim,sig2=sig2,
po.estim=po.estim,invT=invT)
source('gibbs_ceiling_functions.R')
betas.gammas=sample.betas.gammas(xmat=xmat,pr.estim=pr.estim,sig2=sig2,
po.estim=po.estim,invT=invT)
xmat=data.matrix(cbind(1,dat[,c('trat1','trat2')]))
betas.gammas=sample.betas.gammas(xmat=xmat,pr.estim=pr.estim,sig2=sig2,
po.estim=po.estim,invT=invT)
library('mvtnorm')
betas.gammas=sample.betas.gammas(xmat=xmat,pr.estim=pr.estim,sig2=sig2,
po.estim=po.estim,invT=invT)
xmat1=cbind(xmat,xmat*pr.estim)
xtx=t(xmat1)%*%xmat1
prec=(1/sig2)*xtx+invT
var1=solve(prec)
pmedia=(1/sig2)*t(xmat1)%*%po.estim
rmvnorm(1,var1*pmedia,var1)
var1
dim(xmat1)
class(xmat1)
dim(pmedia)
dim(var1)
var1*pmedia
t(pemdia)
t(pmedia)
pmedia
dim(var1)
var1%*%pmedia
rmvnorm(1,var1%*%pmedia,var1)
t(rmvnorm(1,var1%*%pmedia,var1))
rm(list=ls())
library('mvtnorm')
set.seed(1)
#get data
setwd('U:\\GIT_models\\ceiling_effect')
source('gibbs_ceiling_functions.R')
dat=read.csv('fake data.csv',as.is=T)
xmat=data.matrix(cbind(1,dat[,c('trat1','trat2')]))
colnames(xmat)[1]='interc'
#basic settings
ceil1=7
floor1=1
nobs=nrow(dat)
#initial values
betas=gammas=rep(0,ncol(xmat))
betas[1]=mean(dat$po)
sig2=var(dat$po)
mu=mean(dat$pr)
tau2=var(dat$pr)
pr.estim=dat$pr
po.estim=dat$po
#priors
invT=diag(1/10,ncol(xmat)*2)
a.prec=b.prec=0.1
#gibbs stuff
ngibbs=10000
store.betas=matrix(NA,ngibbs,length(betas))
store.gammas=matrix(NA,ngibbs,length(gammas))
store.others=matrix(NA,ngibbs,3)
betas.gammas=sample.betas.gammas(xmat=xmat,pr.estim=pr.estim,sig2=sig2,
po.estim=po.estim,invT=invT)
betas=betas.gammas[1:ncol(xmat)]
gammas=betas.gammas[(ncol(xmat)+1):(2*ncol(xmat))]
betas
gammas
sig2=sample.sig2(xmat=xmat,pr.estim=pr.estim,a.prec=a.prec,b.prec=b.prec,
po.estim=po.estim,betas.gammas=betas.gammas,nobs=nobs)
sig2
mu=sample.mu(nobs=nobs,tau2=tau2,pr.estim=pr.estim)
mu
tau2=sample.tau2(nobs=nobs,a.prec=a.prec,b.prec=b.prec,pr.estim=pr.estim,
mu=mu)
tau2
